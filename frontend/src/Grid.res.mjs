// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as JsxRuntime from "react/jsx-runtime";

function getColorClass(state) {
  switch (state) {
    case 0 :
        return "traversable";
    case 1 :
        return "goal";
    case 2 :
        return "player";
    case 3 :
        return "fire";
    case 4 :
        return "ice";
    case 5 :
        return "water";
    default:
      return "default";
  }
}

function encode_request_body(player_position) {
  return Belt_Option.getExn(JSON.stringify({
                  player_position: player_position
                }));
}

function decode_response_body(payload) {
  var response_body = Js_json.decodeObject(payload);
  if (response_body !== undefined) {
    return response_body;
  } else {
    return {};
  }
}

function decodeCoordinate(coordinate) {
  var obj = Js_json.decodeObject(coordinate);
  if (obj === undefined) {
    return {
            x: -1,
            y: -1
          };
  }
  var match = Js_dict.get(obj, "x");
  var match$1 = Js_dict.get(obj, "y");
  if (match !== undefined && !(!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean" || !(typeof match === "number" && match$1 !== undefined && !(!Array.isArray(match$1) && (match$1 === null || typeof match$1 !== "object") && typeof match$1 !== "number" && typeof match$1 !== "string" && typeof match$1 !== "boolean" || typeof match$1 !== "number")))) {
    return {
            x: Js_math.floor(match),
            y: Js_math.floor(match$1)
          };
  } else {
    return {
            x: -1,
            y: -1
          };
  }
}

function decodeCellTypes(cellTypes) {
  var array = Js_json.decodeArray(cellTypes);
  if (array !== undefined) {
    return Belt_Array.keepMap(array, Js_json.decodeString);
  } else {
    return [];
  }
}

function decodeObstacle(obstacle, cellType) {
  var obj = Js_json.decodeObject(obstacle);
  if (obj === undefined) {
    return [
            -1,
            -1
          ];
  }
  var coordinate = obj["coordinate"];
  var match = decodeCoordinate(coordinate);
  var cellTypes = obj["cell_types"];
  var foundIndex = decodeCellTypes(cellTypes).findIndex(function (cell) {
        return cell === cellType;
      });
  if (foundIndex > -1) {
    return [
            match.x,
            match.y
          ];
  } else {
    return [
            -1,
            -1
          ];
  }
}

function obstaclesToTuples(obstacles, cellType) {
  var array = Js_json.decodeArray(obstacles);
  if (array !== undefined) {
    return Belt_Array.map(array, (function (a) {
                    return decodeObstacle(a, cellType);
                  })).filter(function (param) {
                if (param[0] !== -1) {
                  return param[1] !== -1;
                } else {
                  return false;
                }
              });
  } else {
    return [];
  }
}

function coordinateToTuple(param) {
  return [
          param.x,
          param.y
        ];
}

function obstacleTuplesOfType(obstacles, cellType) {
  var filtered = Js_array.filter((function (obstacle) {
          return obstacle.cell_type === cellType;
        }), obstacles);
  return Js_array.map((function (obstacle) {
                return coordinateToTuple(obstacle.coordinate);
              }), filtered);
}

function tupleToCoordinate(param) {
  return {
          x: param[0],
          y: param[1]
        };
}

function Grid(props) {
  var isInteractive = props.isInteractive;
  var onPlayerMove = props.onPlayerMove;
  var gameState = props.gameState;
  var firePositions = obstacleTuplesOfType(gameState.obstacles, "Fire");
  var icePositions = obstacleTuplesOfType(gameState.obstacles, "Ice");
  var waterPositions = obstacleTuplesOfType(gameState.obstacles, "Water");
  var playerPosition = coordinateToTuple(gameState.player_position);
  var match = React.useState(function () {
        return playerPosition;
      });
  var setPosition = match[1];
  var position = match[0];
  var match$1 = React.useState(function () {
        return true;
      });
  var setIsValidMove = match$1[1];
  var isValidMove = match$1[0];
  var maxX = 14;
  var maxY = 14;
  var grid = Belt_Array.map(Belt_Array.make(15, undefined), (function () {
          return Belt_Array.make(15, 0);
        }));
  var onKeyDown = function (evt) {
    if (!isInteractive) {
      return ;
    }
    var key = evt.key;
    switch (key) {
      case "ArrowDown" :
          setPosition(function (param) {
                var y = param[1];
                var x = param[0];
                if ((x + 1 | 0) <= maxX) {
                  setIsValidMove(function (param) {
                        return true;
                      });
                  return [
                          Math.min(x + 1 | 0, maxX),
                          y
                        ];
                } else {
                  setIsValidMove(function (param) {
                        return false;
                      });
                  return [
                          x,
                          y
                        ];
                }
              });
          evt.preventDefault();
          return ;
      case "ArrowLeft" :
          setPosition(function (param) {
                var y = param[1];
                var x = param[0];
                if ((y - 1 | 0) >= 0) {
                  setIsValidMove(function (param) {
                        return true;
                      });
                  return [
                          x,
                          Math.max(y - 1 | 0, 0)
                        ];
                } else {
                  setIsValidMove(function (param) {
                        return false;
                      });
                  return [
                          x,
                          y
                        ];
                }
              });
          evt.preventDefault();
          return ;
      case "ArrowRight" :
          setPosition(function (param) {
                var y = param[1];
                var x = param[0];
                if ((y + 1 | 0) <= maxY) {
                  setIsValidMove(function (param) {
                        return true;
                      });
                  return [
                          x,
                          Math.min(y + 1 | 0, maxY)
                        ];
                } else {
                  setIsValidMove(function (param) {
                        return false;
                      });
                  return [
                          x,
                          y
                        ];
                }
              });
          evt.preventDefault();
          return ;
      case "ArrowUp" :
          setPosition(function (param) {
                var y = param[1];
                var x = param[0];
                if ((x - 1 | 0) >= 0) {
                  setIsValidMove(function (param) {
                        return true;
                      });
                  return [
                          Math.max(x - 1 | 0, 0),
                          y
                        ];
                } else {
                  setIsValidMove(function (param) {
                        return false;
                      });
                  return [
                          x,
                          y
                        ];
                }
              });
          evt.preventDefault();
          return ;
      default:
        return ;
    }
  };
  React.useEffect((function () {
          if (isInteractive) {
            document.addEventListener("keyup", onKeyDown);
          }
          return (function () {
                    document.removeEventListener("keyup", onKeyDown);
                  });
        }), [isInteractive]);
  React.useEffect((function () {
          if (isValidMove) {
            var encoded = tupleToCoordinate(position);
            onPlayerMove(encoded);
          }
          
        }), [position]);
  React.useEffect((function () {
          document.addEventListener("keyup", onKeyDown);
          return (function () {
                    document.removeEventListener("keyup", onKeyDown);
                  });
        }), []);
  Belt_Array.setExn(Belt_Array.getExn(grid, maxX), maxY, 1);
  Belt_Array.setExn(Belt_Array.getExn(grid, position[0]), position[1], 2);
  Belt_Array.forEach(firePositions, (function (pos) {
          Belt_Array.setExn(Belt_Array.getExn(grid, pos[0]), pos[1], 3);
        }));
  Belt_Array.forEach(icePositions, (function (pos) {
          Belt_Array.setExn(Belt_Array.getExn(grid, pos[0]), pos[1], 4);
        }));
  Belt_Array.forEach(waterPositions, (function (pos) {
          Belt_Array.setExn(Belt_Array.getExn(grid, pos[0]), pos[1], 5);
        }));
  return JsxRuntime.jsx("div", {
              children: grid.map(function (row, y) {
                    return JsxRuntime.jsx("div", {
                                children: row.map(function (state, x) {
                                      return JsxRuntime.jsx("div", {
                                                  className: "cell " + getColorClass(state)
                                                }, String(x));
                                    }),
                                className: "row"
                              }, String(y));
                  }),
              className: "h-[360px]"
            });
}

var make = Grid;

export {
  getColorClass ,
  encode_request_body ,
  decode_response_body ,
  decodeCoordinate ,
  decodeCellTypes ,
  decodeObstacle ,
  obstaclesToTuples ,
  coordinateToTuple ,
  obstacleTuplesOfType ,
  tupleToCoordinate ,
  make ,
}
/* react Not a pure module */
